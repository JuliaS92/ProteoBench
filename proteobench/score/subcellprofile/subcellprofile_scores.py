"""Basic scoring module for Subcellprofile modules."""

import json
from io import StringIO

import domaps
import numpy as np


class Subcellprofile_Scores:
    """
    Scoring module for calculation of metrics from the Subcellular Profiling module.
    """

    def __init__(self):
        """Initialise the Subcellprofile_Scores object."""
        self.sd: domaps.SpatialDataSet = None
        self.sdc: domaps.SpatialDataSetComparison = None

    def generate_SpatialDataSet(
        self,
        content: StringIO,
        settings: dict,
    ) -> None:
        """
        Generate a SpatialDataset object from the content and settings.

        Input for this function should be generated by the io module.

        Parameters
        ----------
        content : StringIO
            The content of the dataset.
        settings : dict
            The settings for the dataset.
        """
        sd = domaps.SpatialDataSet.from_settings(settings)
        sd.run_pipeline(content=content)
        self.sd = sd

    def create_sd_json(self, filename: str) -> None:
        """
        Create the JSON download file for the analysed datasets.

        Parameters
        ----------
        filename : str
            The name of the file to save the JSON to.
        """
        return json_download(self.sd)

    def run_SpatialDataSetComparison(self):
        """
        Generate a SpatialDataSetComparison object from the SpatialDataSet object.
        """
        self.sdc = domaps.SpatialDataSetComparison()
        self.sdc.json_dict = self.sd.analysed_datasets_dict
        self.sdc.read_jsonFile()
        self.sdc.calc_biological_precision()
        self.sdc.calculate_global_scatter(metric="manhattan distance to average profile", consolidation="average")

    def get_metrics(self) -> dict:
        """
        Return the metrics from the SpatialDataSetComparison object.

        Returns
        -------
        dict
            The metrics from the SpatialDataSetComparison object.
        """
        results = {}
        results["depth_id_total"] = self.sdc.df_quantity_pr_pg_combined.query(
            "filtering=='before_filtering' and type=='total'"
        )["number of protein groups"]
        results["depth_profile_intersection"] = self.sdc.df_quantity_pr_pg_combined.query(
            "filtering=='after_filtering' and type=='total'"
        )["number of protein groups"]
        results["depth_id_total"] = self.sdc.df_quantity_pr_pg_combined.query(
            "filtering=='before_filtering' and type=='intersection'"
        )["number of protein groups"]
        results["depth_profile_intersection"] = self.sdc.df_quantity_pr_pg_combined.query(
            "filtering=='after_filtering' and type=='intersection'"
        )["number of protein groups"]
        results["median_profile_reproducibility"] = self.median_profile_reproducibility()
        results["mean_complex_scatter"] = self.complex_scatter_unnormalized()
        return results

    def median_profile_reproducibility(self):
        """
        Determine the median of distances for a dataframe.

        Returns
        -------
        float
            Median of the distances.
        """
        return np.median(self.sdc.distances.to_numpy())

    def complex_scatter_unnormalized(self, mode="mean") -> float:
        """
        Return the mean complex scatter from the SpatialDataSetComparison object.

        Parameters
        ----------
        mode : str
            The mode to calculate the complex scatter. Default is 'mean'.

        Returns
        -------
        float
            The mean complex scatter.
        """
        complex_scatter = self.sdc.aggregate_cluster_scatter(
            normalization=None,
            aggregate_proteins=True,
            aggregate_maps=False,
            min_size=5,
        )

        if mode == "mean":
            return complex_scatter.mean()["distance"]
        else:
            raise ValueError(f"Invalid mode {mode}. Please use 'mean'.")
